# ProofText — Система проверки статей на плагиат и генерации справок

ProofText — это веб-приложение для анализа текстовых докладов на оригинальность и вероятность генерации нейросетью, с возможностью получения PDF-справок.

---

## Основные возможности

- Регистрация и управление пользователями
- Загрузка и хранение текстовых докладов
- Анализ докладов на оригинальность и AI-генерацию (модель RoBERTa)
- Просмотр информации о докладе с деталями анализа
- Генерация и скачивание PDF-справок с результатами анализа
- Личный кабинет с управлением докладами и профилем

---

## Используемые технологии

- Python 3.10+
- Django 5.x
- Django REST Framework
- Библиотеки для NLP: spaCy, gensim (планируется интеграция)
- textdistance, pandas (для обработки и вычислений)
- Pytest для тестирования
- JWT для аутентификации API
- Docker (для контейнеризации и развертывания)
- ReportLab для генерации PDF

---

## Установка и запуск

1. Клонируйте репозиторий:

git clone https://github.com/yourusername/prooftext.git
cd prooftext
Создайте и активируйте виртуальное окружение:


python -m venv .venv
source .venv/bin/activate  # Linux/MacOS
.venv\Scripts\activate     # Windows
Установите зависимости:

pip install -r requirements.txt
Выполните миграции базы данных:

python manage.py migrate
Запустите сервер разработки:

python manage.py runserver
Откройте в браузере http://127.0.0.1:8000

## Конфигурация
Настройки базы данных — в core/settings.py

Путь к шрифту для PDF — положите DejaVuSans.ttf в папку static/

JWT и другие настройки безопасности настраиваются в settings.py

## Структура проекта
articles/ — приложение для работы с докладами и анализом

users/ — управление пользователями и профилем

core/ — основные настройки проекта

static/ — статические файлы, включая шрифт для PDF

templates/ — HTML-шаблоны

### Генерация PDF-справки
При просмотре доклада нажмите кнопку "Получить справку (PDF)" — сгенерируется отчет с результатами анализа и автоматически скачивается.

---

## Многопоточность и блокировки (Threading and Locking)

В системе ProofText реализовано кэширование результатов внешнего поиска (Google Search) для повышения производительности и снижения нагрузки на API.  Для обеспечения безопасного доступа к файлу кэша при одновременном обращении из разных потоков используются потоки (threading) и блокировки (locking).

**Зачем это нужно?**

*   **Параллельный доступ:**  Веб-приложение, такое как ProofText, может обрабатывать множество запросов одновременно.  Каждый запрос может выполняться в отдельном потоке.  Если несколько потоков попытаются одновременно читать и записывать файл кэша, это может привести к повреждению данных или гонкам данных.
*   **Предотвращение гонок данных:**  Гонка данных возникает, когда два или более потока имеют доступ к общему ресурсу (в данном случае, файлу кэша) и по крайней мере один из них пытается изменить этот ресурс.  Блокировки предотвращают гонки данных, гарантируя, что только один поток имеет доступ к файлу кэша в любой момент времени.

**Как это реализовано?**

1.  **`CACHE_LOCK = threading.Lock()`:**  Создается объект блокировки (`threading.Lock()`) для управления доступом к файлу кэша.

2.  **`with CACHE_LOCK:`:**  При чтении или записи файла кэша код заключается в блок `with CACHE_LOCK:`.  Это гарантирует, что перед выполнением операций с файлом кэша поток должен получить блокировку.  Если другой поток уже удерживает блокировку, текущий поток будет ждать, пока блокировка не будет освобождена.

3.  **Безопасность записи:** Функция `save_cache(cache_data)`  использует блокировку для обеспечения атомарной записи в файл кэша. Это предотвращает частичную или поврежденную запись, которая может произойти, если несколько потоков попытаются одновременно изменить файл.

4. **Почему выбран этот вариант?**: Использование threading.Lock() является относительно простым и эффективным способом синхронизации доступа к общему ресурсу (файлу кэша) в данном контексте.  Альтернативные варианты, такие как использование более сложных механизмов синхронизации или баз данных для кэширования, могут быть излишними для этой задачи и внести ненужную сложность в код.  threading.Lock() предоставляет достаточную защиту от гонок данных и повреждения кэша при относительно небольших накладных расходах.

**Преимущества использования потоков и блокировок:**

*   **Безопасность данных:**  Гарантируется целостность данных в файле кэша.
*   **Производительность:**  Позволяет другим потокам продолжать работу, пока один поток выполняет операции с кэшем.
*   **Простота реализации:**  `threading.Lock()` предоставляет простой и понятный способ синхронизации.

## Тестирование
Для запуска тестов используйте:

pytest

### Планы развития
Интеграция реальных алгоритмов проверки плагиата (spaCy, gensim)

Интеграция нейросетевых API для оценки вероятности AI-генерации текста

Расширение интерфейса личного кабинета

Автоматизация удаления и редактирования докладов

Docker-контейнеризация для удобного развертывания

# Контакты


Автор: Евгений Ясаков


Email: uskat2@yandex.ru
